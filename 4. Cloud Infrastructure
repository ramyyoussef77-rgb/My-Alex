4. Cloud Infrastructure

Firebase Setup

// firebase.json
{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "functions": {
    "source": "functions",
    "runtime": "nodejs18"
  },
  "storage": {
    "rules": "storage.rules"
  },
  "hosting": {
    "public": "admin-panel/build",
    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"]
  }
}

// Cloud Functions (functions/index.js)
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const axios = require('axios');

admin.initializeApp();

// Scheduled function to fetch Facebook posts
exports.fetchFacebookPosts = functions.pubsub
  .schedule('every 30 minutes')
  .onRun(async (context) => {
    const pages = [
      '1CuNA8fLsW', '19FucQXpny', '14GTdbckaVK',
      '1B981DguFm', '17AVC5M4Uk', '1CFFKVd3jz', '16mFj19vcE'
    ];
    
    for (const pageId of pages) {
      try {
        const response = await axios.get(
          `https://graph.facebook.com/v18.0/${pageId}/posts`,
          {
            params: {
              access_token: functions.config().facebook.access_token,
              fields: 'id,message,created_time,permalink_url,attachments',
              limit: 4
            }
          }
        );
        
        await admin.firestore()
          .collection('newsCache')
          .doc(pageId)
          .set({
            sourceName: pageId,
            posts: response.data.data,
            lastFetched: admin.firestore.FieldValue.serverTimestamp(),
            nextFetch: admin.firestore.Timestamp.fromDate(
              new Date(Date.now() + 30 * 60 * 1000)
            )
          });
      } catch (error) {
        console.error(`Error fetching posts for ${pageId}:`, error);
      }
    }
  });

// Message moderation function
exports.moderateMessage = functions.firestore
  .document('chatRooms/{roomId}/messages/{messageId}')
  .onCreate(async (snap, context) => {
    const message = snap.data();
    
    // Simple content filtering
    const bannedWords = ['spam', 'inappropriate']; // Add Arabic words
    const containsBannedWord = bannedWords.some(word => 
      message.text.toLowerCase().includes(word)
    );
    
    if (containsBannedWord) {
      await snap.ref.update({
        isModerated: true,
        moderationReason: 'Inappropriate content detected'
      });
      
      // Notify moderators
      await admin.firestore()
        .collection('moderationQueue')
        .add({
          type: 'message',
          messageId: context.params.messageId,
          roomId: context.params.roomId,
          reason: 'Automated filter triggered',
          timestamp: admin.firestore.FieldValue.serverTimestamp()
        });
    }
  });

// Complaint escalation function
exports.escalateComplaint = functions.firestore
  .document('complaints/{complaintId}')
  .onUpdate(async (change, context) => {
    const before = change.before.data();
    const after = change.after.data();
    
    // Auto-escalate if complaint is older than 48 hours and still pending
    const createdAt = after.createdAt.toDate();
    const now = new Date();
    const hoursDiff = (now - createdAt) / (1000 * 60 * 60);
    
    if (hoursDiff > 48 && after.status === 'pending' && after.escalationLevel < 2) {
      await change.after.ref.update({
        escalationLevel: after.escalationLevel + 1,
        priority: after.priority === 'low' ? 'medium' : 
                 after.priority === 'medium' ? 'high' : 'critical'
      });
    }
  });
